@page "/search/"
@page "/search/{Query}/{Page:int}"

@using BlazingFastPublishQueue.Server.Services
@using BlazingFastPublishQueue.Server.Models
@using BlazingFastPublishQueue.Server.ViewModels
@using System.Threading

@inject ElasticSearchService service
@inject NavigationManager NavigationManager

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-16">
    <MudText Typo="Typo.h3" GutterBottom="true">Search</MudText>
    <MudText Class="mb-8">This component demonstrates fetching data from the server.</MudText>

    <MudPaper Class="d-flex align-center mud-full-width px-4 py-2 mt-6" Elevation="0">
        <MudToolBarSpacer />
        <MudButton IconColor="@(realtime ? Color.Success : Color.Error)" StartIcon="@Icons.Custom.Uncategorized.AlertSuccess" OnClick="OnButtonClick" Variant="Variant.Text">Realtime is @(realtime ? "on" : "off")</MudButton>
    </MudPaper>

    @if (!publishTargets?.Any() ?? true)
    {
        <p> loading ... </p>
    }
    else
    {
        <FilterMenu Filter="@filter" OnFilterChanged="OnQuerySubmit" UserSearch="UserSearch" Servers="servers" Publications="publications" PublishTargets="publishTargets" />
    }

    <MudGrid>
        <MudItem xs="12">
            <MudTable ServerData="@(new Func<TableState, Task<TableData<PublishTransactionViewModel>>>(ServerReload))" Hover="true" SortLabel="Sort By" Elevation="0" @ref="table" OnRowClick="@OnRowClick" T="PublishTransactionViewModel">
                <HeaderContent>
                    <MudTh><MudTableSortLabel SortLabel="itemType" T="PublishTransactionViewModel">ItemType</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortLabel="publishedItemId" T="PublishTransactionViewModel">PublishedItemId</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortLabel="published" T="PublishTransactionViewModel">Published</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortLabel="publication.keyword" T="PublishTransactionViewModel">Publication</MudTableSortLabel></MudTh>
                    <MudTh><MudTableSortLabel SortLabel="publishtarget" T="PublishTransactionViewModel">PublishTarget</MudTableSortLabel></MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="FlightNum">@context.PublishTransaction.ItemType</MudTd>
                    <MudTd DataLabel="Origin">@context.PublishTransaction.PublishedItemId</MudTd>
                    <MudTd DataLabel="OriginAirportID">@context.PublishTransaction.Published</MudTd>
                    <MudTd DataLabel="Dest">@context.PublishTransaction.Publication</MudTd>
                    <MudTd DataLabel="DestAirportID">@context.PublishTransaction.PublishTarget</MudTd>
                </RowTemplate>
                <PagerContent>
                    <MudTablePager PageSizeOptions="new int[] { 10, 20, 50, 100 }" />
                </PagerContent>
            </MudTable>
        </MudItem>
    </MudGrid>

</MudContainer>

@code {
    [Parameter]
    public int Page { get; set; } = 1;

    [Parameter]
    public string? Query { get; set; }

    private Filter filter { get; set; } = new Filter();
    private bool realtime { get; set; } = false;

    private IEnumerable<PublishTransactionViewModel>? transactions;
    private IEnumerable<string>? publishTargets;
    private IEnumerable<string>? servers;
    private IEnumerable<string>? publications;

    protected override async Task OnInitializedAsync()
    {
        var filters = await service.GetFilters();
        publishTargets = filters["publishTargets"].Select(i => i.Key);
        servers = filters["servers"].Select(i => i.Key);
        publications = filters["publications"].Select(i => i.Key);
    }

    private MudTable<PublishTransactionViewModel> table;

    private async Task<TableData<PublishTransactionViewModel>> ServerReload(TableState state)
    {
        Page = state.Page;
        transactions = await service.GetTransactions(filter, Page, state.PageSize, state.SortLabel, state.SortDirection);

        return new TableData<PublishTransactionViewModel>() { TotalItems = transactions.FirstOrDefault()?.Total ?? 0, Items = transactions };
    }

    private async Task<IEnumerable<string>> UserSearch(string value) => await service.GetSuggestions(value, "userCompletion");

    private async Task OnQuerySubmit()
    {
        await table.ReloadServerData();
        //NavigationManager.NavigateTo($"/search/{Query}/{Page}");
    }

    private void OnRowClick(TableRowClickEventArgs<PublishTransactionViewModel> role)
    {
        NavigationManager.NavigateTo($"/detail/{role.Item.Id}");
    }

    private Timer timer;
    private async Task OnButtonClick()
    {
        realtime = !realtime;

        if (realtime)
        {
            timer = new Timer(new TimerCallback(_ =>
            {
            // Note that the following line is necessary because otherwise
            // Blazor would not recognize the state change and not refresh the UI

            InvokeAsync(async () =>
                {
                    await table.ReloadServerData();
                    StateHasChanged();
                });

            }), null, 1000, 1000);
        }
        else
        {
            await timer.DisposeAsync();
        }

    }
}
